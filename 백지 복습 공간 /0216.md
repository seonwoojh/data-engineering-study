# Day2

# Python

### Generator

- 반복(Iterable)을 제어할 수 있는 루틴 형태 혹은 객체를 뜻함. 일반적으로 반복문은 정해진 range까지 전부 순회를 하는 반면 Generator를 사용하면 순회를 제어할 수 있게 된다. 예를 들어 1번째 값을 얻은 후 다른 작업을 하다 두번째 값을 얻을 수 있다는 말.
- `yield`를 통해서 쉽게 구현이 가능함. return과 역할이 비슷한데 함수에서 return을 하면 함수가 종료되는 **반면 yield는 함수를 종료시키지 않고 Generator를 반환한다.** 반환된 Generator는 `next` 함수를 통해 제어가 가능함

    ```python
    def hi():
    	num = 0
    	while True:
    		num += 1
    		yield num

    gen = hi() #generator 반환함
    next(gen) #0을 반환함.
    next(gen) #1을 반환함

    ```

- for 단축 구문도 generator을 반환한다.

    ! [Imgur](https://i.imgur.com/l5Mnk5Y.png)

- 대표적인 generator 함수로 `range`가 있음.  range는 `iterable`한 속성을 가지며 for문에서 많이 사용되는데 이 또한 인덱스에 접근할 때 값을 생성하는 구조라고 보면 됨

    ```python
    range(0,10) #range(0, 5)출력
    list(range(0,10)) #[0,1,2,...,9]
    for num in range(0,10): #반복문에서 많이 사용됨
    	pass

    import sys
    sys.getsizeof(range(0,10000000)) #48 반환
    ```

### Iterator

`iter` 함수를 사용하면 iterable한 객체를 iterator 객체로 만들 수 있음. 

iterator는 next() 함수를 통해서 값 순회를 제어할 수 있음(Generator와 똑같). 또한 `__next__` 메소드를 통해서 직접 실행도 가능함

```python
iter([1,2,3])
```

[참고] [https://wikidocs.net/16068](https://wikidocs.net/16068)

### str과 repl

[참고] [https://shoark7.github.io/programming/python/difference-between-__repr__-vs-__str__](https://shoark7.github.io/programming/python/difference-between-__repr__-vs-__str__)

- `repl`은 객체를 표현하는 함수로 문자열을 반환함. 보통 우리가 대화형(`REPL`)으로 코딩을 할 때 객체를 치면 나오는 구문이 repl을 통해서 나온 것이라고 보면 됨. 클래스에 `__repl__` 을 통해서 값을 바꿔줄 수 있는데 repl 메소드에 값을 넣으면 __repl__을 호출함

    ```python
    repl(3) #"3"
    repl([1,2,3]) #'[1,2,3]'

    class Custom:
    	def __repl__(self):
    		return "Custom Repl"
    	
    repl(Custom()) #"Custom Repl
    ```

- `str`은 객체를 문자열화할 때 사용함. print할 때 객체의 `__str__`이 불리며 str은 __str__을 호출한다고 보면 됨.

    ```python
    str(3) #3

    class Custom:
    	def __str__(self):
    		return "Custom Str"

    str(Custom()) #Custom Str

    ```

### Dataclass

C에서 Structure가 있다면 Python에는 Dataclass가 있다. class위에 annotation을 붙여서 사용가능함.

- 파이썬 3.7부터 지원됐던 거라 이하에도 호환되도록 `dataclasses` 모듈을 import하면 좋음

```python
@dataclass
class Item:
	def hi():
		pass
```

[참고] [https://sjquant.tistory.com/30](https://sjquant.tistory.com/30)

### List comprehension

- Generator 객체임

```python
[i ** 2 for i in [1,2,3,4]]
```

### Python 나누기

```python
5 / 2 #2.5 나눈 값
5 // 2 #2 몫
divmod(5,2) #(2,1) 몫과 나머지 반환
```

### Print 잘 쓰기

```python
print("1", "2", sep=", ")
print("1", "2", end="!!")
```

### 파이썬 리스트 기본 구조

- `list`는 객체 실제 메모리 값의 포인터들을 모아놓은 객체임. 포인터들을 링크드 리스트 형태로 관리하고 있어서 queue, stack 기능 모두 사용이 가능함.
- 다양한 값을 단일 리스트에 넣을 수 있는데 포인터를 목록을 관리하기에 가능함

### List의 pop(0)

- 시간복잡도가 O(n)임. 이유는 링크드리스트 구조이기에 first를 찾아서 다른 노드들의 shift가 일어남

### List Slicing

- `startIndex:endIndex:IntervalSize` 로 구성된다
- range와 마찬가지로 endIndex 미만으로 범위값이 형성됨

```python
a = [1,2,3,4]

a[::-1] #reverse와 동일
a[1:2:] #index 1부터 2미만까지, 즉 2 하나만 반환함
```

### List sort

파이썬에서 list의 sort는 `team sort`. 유명한 sort 기법 `quick sort`와 `merge sort` 를 합친 sort 기법인데, 정렬할 리스트가 어느정도 잘 정돈되었다는 가정하에 만들어졌음. 만약 정렬이 잘 되어있으면 team sort 는 O(n)까지 시간 복잡도가 내려감

### Dictionary

- 3.7 버전부터 입력순서가 보장됨. 그래서 `keys()`, `values()`로 접근이 가능한듯
- `defaultdict`, `Counter` 좋음

```python
#defaultdict는 기본 값으로 0이 생성됨. 그래서 아래와 같은 패턴이 사용가능함
a = collections.defaultdict(int)
a["number"] +=1 #특징 추출하면서 특징별 count하기 좋은 기능

#Counter는 갯수를 계산해서 딕셔너리로 리턴함
b = collections.Counter([1,1,2,3,4,4,4])
b.most_common(2) #{4: 3, 1: 2} 반환하는데 key는 count되는 값, value는 count 횟수가 들어감

```

### muptiple values

일반적으로 `,`로 값을 반환하는 경우 이는 `tuple`에서 ()가 생략된 구조다.

tuple에서 unpacking할 때 `*` 를 사용할 수도 있네 ㅋ

```python
def a():
	return 1,2,3

type(a()) #tuple
(a()) #(1,2,3)
print(*(1,2,3)) #1 2 3
```

# Algorithm

### 빅O, 쎄타, 오메가

빅O는 n이 무한대로 간다고 했을 때 복잡도를 표현하는 방식

빅O는 Upper Bound(상한), 오메가는 Lower Bound(하한), 쎄타는 평균을 의미함

n이 고정되어 있을 때 입력 값에 따라 최선, 최악, 평균이 결정된다. 이는 빅O의 상한과는 무의미함.

[책]104P

# CS

### 스왑

메모리와 디스크에서 스왑이라는 건 메모리가 부족하면 디스크의 일부 공간을 가져가는데 이를 스왑이라고 함. 스왑이 되면 디스크를 읽어들이므로 속도가 느려질 수 밖에 없다. 메모리를 늘리거나 병목 지점을 해결해야 한다.

### 부하 측정(CPU, I/O)

`top` 명령어로 load average, 프로세스들 상태(cpu, memory) 확인 가능

`sar`로 timely하게 cpu 별로 상세 상태 (user, sys, iowait 등) 확인 가능

**cpu**

- %us : 사용자 영역에서 cpu가 사용되는 시간
- %sys : 커널 영역에서 cpu가 사용되는 시간

**idle : cpu 놀고 있는 시간**

- %iowait : io때문에 block일 때 cpu가 얼마나 idle하냐에 대한 수치. 만약 특정 프로세스가 io 블락이면 cpu는 널널한 프로세스들이랑 놀아주거나 idle할 경우가 높음

(참고)[https://support.hpe.com/hpesc/public/docDisplay?docId=c02783994](https://support.hpe.com/hpesc/public/docDisplay?docId=c02783994)

### flush

일시적인 상태의 데이터를 영구적인 상태로 변경하는 것. 일반적으로 메모리에 있는 데이터를 디비로 옮긴 것을 생각해볼 수 있음

# 기타

### ASCII와 Unicode

ASCII는 문자당 1바이트를 차지함. 그러나 중국어 한글같이 받침이 있는 경우 문제가 있어 Unicode가 나옴. Unicode는 넉넉하게 4바이트를 차지함.

그러나 굳이 4바이트를 쓰지 않아도 되는 문자들이 많을 경우 메모리 낭비임. 그래서 Unicode를 인코딩할 때 동적으로 사이즈를 조절해주는 기법으로 `UTF-8`이 있음.

그러나 Python은 문자 인코딩에서 UTF-8을 사용하지 않는데 이유는 가변 길이라서 문자열을 슬라이싱할때 인덱스를 찾을 때 Full Scan을 하지 않으면 힘든 구조. 그래서 다른 인코딩 기법을 사용한다고 함.
