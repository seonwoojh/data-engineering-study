# Day8

# 파이썬

## , 연산자

```python
a = [[1],[2],[3]]
a += [4], #append와 비슷한 역할을 한다 [[1],[2],[3],[4]]

```

### Sorted Cmp

python 3버전에서는 sorted 안에 cmp가 없이 key만 있다. key는 함수에 인자 값이 하나라서 비교하는 구문을 넣을 수 없다. 그래서 `from functools import cmp_to_key` 를 사용하면 된다

```python
from functools import cmp_to_key
sorted(a, key=cmp_to_key(lambda x,y : x-y))
```

### String to Int List

```python
list(map(int,"1234"))
```

### 파이썬 리스트 중복 제거하기

`set`을 이용해서 list(set(arr)) 을 이용할 수 있다. 그러나 문제는 순서가 보장되지 않는다는 것

순서 보장이 필요할 때는 `반복문`으로 사용하는 게 베스트인듯

### Itertools Product

배열을 넣었을 때 데카르트 곱을 해준다. 쉽게 이야기해서 조합 결과를 반환한다는 이야기. 깊이 탐색 대신 Pythonic하게 사용할 수 있음.

보통 배열을 비구조화한 후 사용한다

```python
from itertools import product

arr1 = [1,2,3]
arr2 = ["12","34","56"]
arr3 = [[1,2],[3,4],[5,6]]
list(product(*arr1)) #[1,2,3]
list(product(*arr2)) #[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5], ...
```

# 알고리즘

### 다익스트라

다익스트라 알고리즘은 그리디 알고리즘 모태로 하며 최단 경로 혹은 최단 거리를 이용할 때 자주 사용되는 알고리즘임. 

일반적으로 다익스트라는 O(n*2)의 복잡도를 가지나 우선순위 큐(힙)를 사용하면 O(nlogV)로 줄일 수 있음

### 정렬

정렬 종류는 크게 버블, 선택, 삽입, 머지, 퀵 정도가 있다.

- 버블 정렬: O(n*2)로 말그대로 Brute Force 방식임
- 선택 정렬, 삽입 정렬 : O(n*2)임. 삽입 정렬은 정렬이 처음에 잘 되어있으면 O(n)까지 가능
- 머지 정렬 : divide and conquer로 동작하며 O(NlogN)으로 최선, 최악 모두 동일한 퍼포먼스 보여줌
- 퀵 정렬 : partion 기반으로 동작함. 최선은 O(NlogN)으로 머지 정렬보다 빠를 때도 있으나, 최악의 경우 O(n*2)라 현업에서 많이 사용되진 않는다고 함.

### 그리디

휴리스틱하게 서브 루틴(태스크)마다 최적의 해를 찾아나가는 방식. 그냥 눈 앞에 좋은 거를 찾아나가는 방식이라고 생각하면 됨. 눈앞의 최선의 경우로 가더라도 문제가 없는 상황에서 사용하면 좋다.

### DFS에서 Stack, 재귀함수 인자

**stack안에 넣을 것은 변화하는 값이다.** 일반적으로 DFS를 할 때 **순회하면서 변화하는 인덱스나 누적시킬 것 등에 인자를 추가해야 함.** 재귀함수도 마찬가지다. 이전에 재귀함수를 하면서 느꼈던 점은 반복문으로 처리할 게 있다면 재귀로 우아하게 생각도 해보기

# 네트워크

### HTTP2 & HTTP3

HTTP2는 기본적으로 TCP 위에서 동작함. 또 멀티플렉싱이 있다곤 하지만 TCP 자체의 HOLB를 막지는 못함. HOLB는 말그대로 병목현상임. 

TCP는 패킷들의 순서를 보장하므로 만약 패킷이 손실이 나면 다음 시퀀스의 패킷은 재전송이 될 때까지 기달려야만 함. 이는 HTTP2의 멀티플렉싱으로 여러 스트림으로 패킷을 보낸다고 하더라도 한 스트림 찐빠가 나면 병목은 그대로임.

HTTP3에 사용되는 프로토콜은 QUIC & UDP임. QUIC는 HTTP2와 마찬가지로 multiplexing이 적용되어 있음. UDP 위에서는 스트림끼리 독립적이므로 에러가 나도 해당 스트림만 스탑하면 됨. HTTP2 처럼 HOLB를 겪을 필요가 없음. 

또한 HTTP3는 기존에 TCP의 Handshaking이 필요하지 않고 RTT(Round Trip Time)이 한 번이면 바로 연결이 됨. TCP는 TLS 핸드쉐이킹까지 거치면 총 3RTT가 필요함.

[https://evan-moon.github.io/2019/10/08/what-is-http3/](https://evan-moon.github.io/2019/10/08/what-is-http3/)

### NAT, 로드밸런싱

NAT는 Network Address Transport의 약자로 공유기에 있는 기능을 생각하면 됨. 공인 IP 주소 하나로 여러 사설 IP들을 만들어 관리하는 기능을 가진다. 

그래서 실제로 사설 IP를 사용하는 입장에서 외부 서버와 통신하려면 NAT를 통해 사설 IP → 공인 IP로 대체되는 과정이 필요함. 그렇지 않으면 수신측에서는 어디로 IP를 쏴줘야할 지 모를 거임 ㅎㅎ

외부 트래픽이 다시 송신자로 돌아갈 때는 NAT의 테이블을 통해 공인 IP → 사설 IP로 다시 바꿔줌

로드밸런싱은 결국 NAT를 통해서 외부와 real server를 중개해주는 역할을 함. NAT 기능을 이용하는 거임.

[https://pakss328.medium.com/로드밸런서란-l4-l7-501fd904cf05](https://pakss328.medium.com/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C%EB%9E%80-l4-l7-501fd904cf05)

[https://www.stevenjlee.net/2020/07/11/이해하기-nat-network-address-translation-네트워크-주소-변환/](https://www.stevenjlee.net/2020/07/11/%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-nat-network-address-translation-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98/)

### RPC, WEBRTC

RPC는 REST와 다르게 Remote Prodcedure Call의 약자로 클라이언트가 직접 서버의 함수를 호출하는 프로세스간 통신 기술이라고 보면 됨. IDC 라는 정의서를 가지고 클라이언트가 서버의 함수를 호출할 수 있음 

**대표적으로 `MSA`에서 RPC가 사용됨. MSA는 각기 다른 Process로 데이터를 처리하므로 서로 간의 통신을 위해 RPC를 사용함. 서로 다양한 프로그래밍 언어로 구현되어 있을텐데 프로시저 호출만 하면 결과를 얻을 수 있으므로 유용하게 사용됨.**

`WebRTC`는 웹 브라우저 간의 통신을 하는 기술로 음성, 화상 통화 , 영상처리 등 P2P 스트리밍을 처리하는 곳에서 널리 사용됨.