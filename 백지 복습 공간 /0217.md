# Day3

### CPU 스케쥴링

운영체제는 프로세스들에게 cpu를 공평하게 분배한다. 이를 통해 자원을 효율적으로 관리할 수 있음

![https://i.imgur.com/ManqjkQ.png](https://i.imgur.com/ManqjkQ.png)

프로세스 실행은 CPU Burst와 I/O Burst로 나뉨. CPU로 일 열심히하다가 IO있으면 블라킹으로 인해 cpu 할당을 받을 수 없음.

참고 : [https://dduddublog.tistory.com/23](https://dduddublog.tistory.com/23)

### 쓰레드와 프로세스와 CPU 코어

프로세스나 쓰레드는 각기 다른 CPU 코어를 할당받을 수 있음.  한 프로세스 안의 복수의 쓰레드도 각각의 cpu를 할당받을 수 있음

### 정규표현식 간단하게만

하 자꾸 까먹는 정규표현식

```python
^ 입력 시작 부분에 대응됨 , 문자열 앞에서는 not이랑 같음 ex) ^a-z
w 문자열(문자,숫자)에 대응됨
W 단어 문자(w가 아닌 것)에 대응
[] 문자 표현할 때 사용됨 ex) [a-z]

```

### Int 기본 바이트

파이썬은 기본적으로 8바이트(옛날에는 long이 8, int가 4)로 Int를 가지지만 동적으로 무제한으로 늘어날 수 있음

참고 : [https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/](https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/)

32비트 이상 컴퓨터는 int를 4바이트로 사용함~

### 동적 배열 사이즈 늘리기

- 32x는 1포인터당 4바이트가 ,64x 컴퓨터는 1포인터당 8바이트가 할당됨. 즉 포인터의 최대 크기가 32비트 머신은 메모리 4GB까지 밖에 지정이 안됐음...;;
- 보통 동적 배열 사이즈는 늘릴 때 더블링(기존의 2배)을 한다. 그러나 파이썬은 좀 다르게 사이즈를 늘린다.

### in

- dicrectory에서 key 뽑을 때 사용이 가능
- in은 일반 반복문 돌리는 것보다 속도가 더 빠름

### 투포인터 기법

- 두개의 포인터로 연속적으로 값을 순회하는 기법. 보통 양 끝 쪽에서 서로 만날 때까지 슬라이딩시키게 많이 사용함
- 보통 브루트포스보다 복잡도를 1차 낮출 수 있음

### Max, min 기법

보통 투포인터 할 때 maximum = max(maximum, ... ) 기법으로 순회를 할 때 max나 min을 뽑아가는 방식을 사용함. 최대 최소로 뭔가 활용할 때 유용한 듯

### 연결리스트

알고리즘 쓸 때 연결리스트 참조 포인터를 헷갈리면 안됨.

- 일반적으로 변수는 단순히 포인터, 가리키는 역할을 함. 실제로 링크드리스트가 변화하는 시점은 링크객체.next=... 로 접근했을 때임
- 포인터가 요리조리 왔다갔다하다보니 위에 cur, prev, root 같이 head를 가리키는 변수들을 추가로 선언하는 편임.

### 런너기법

일반적으로 LinkedList는 길이를 모르므로 계속 순회해야함. 이때 딱 절반으로 가고 싶다면 하나는 2개씩 건너뛰는 Fast Runner와 1개씩 뛰는 Slow Runner를 활용하면 됨. Fast Runner가 다 도착하면 Slow Runner는 절반에 가 있을 거임 

### 데크

`collections.deque` 로 선언해서 사용할 수 잇음. list와 다르게 popLeft()을 할 때 시간 복잡도가 O(1)임 ㅋ

### And or 순서

- and가 or보다 더 우선순위가 높음. 그래서 먼저 호출됨

### 다중할당

다중으로 할당할 때 한 트랜잭션 안에 동작들이 전부 동작함. 

[참고] 파이썬 알고리즘 인터뷰 211P

### Reduce

`.reduce(function, 배열, 기본값)` 으로 사용됨

```python
functools.reduce(lambda x,y : x+y, [1,2,3,4,5], 0)
#15 반환
#x에는 새로운 요소, y에는 sum값이 들어감
```