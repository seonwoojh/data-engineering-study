# Day11

## 데이터베이스

### ACID

트랜잭션이 일어나는 데이터베이스의 기본 속성

Atomic : 원자성. 하나의 트랜잭션 원자는 실패, 성공 즉 0,1만 가진다. 

Consistency : 트랜잭션에 의해 바뀐 데이터는 일관성을 가진다(시스템 속성을 똑같이 유지함)

Isolation : 트랜잭션 수행 중에 다른 트랜잭션이 영향을 끼치지 않는다. 

Durability : 바뀐 데이터는 영구적으로 유지한다

ACID 모두 구현하는 건 힘듬. CPU 선점이나 자원할당 등 다양한 이슈로 한 트랜잭션이 제대로 처리되지 않을 수 있음. 그래서 `Lock` 을 사용함. mysql은 테이블 락을 사용함. 

### 몽고디비 트랜잭션

몽고디비는 트랜잭션을 지원한다. 4버전부턴가 트랜잭션 지원함. 근데 트랜잭션이 replica set에서만 지원된다고 이야기 함

몽고디비는 document형 db이고 데이터를 객체 구조로 유연하게 다룰 수 있음 

[https://kay0426.tistory.com/52](https://kay0426.tistory.com/52)

## 정규표현식

- ^ : 맨 처음에 쓰이면 첫 시작 문자를 의미함. 만일 [] 안에 있으면 반대되는 의미를 뜻함
- Escape : w, s 같이 그냥 문자로 찍히지 않고 특정한 예약어를 사용할 때 \를 사용함
- $ : 마지막을 의미함. 문자$로 표현함 ex: s$ : 맨마지막에 s로 끝남
- [] : 문자의 집합이나 범위를 뜻함

# CS

## CPU 스케쥴링

CPU 스케쥴링은 결국 프로세스에게 효율적인 자원을 주기 위한 방식임. 

스케쥴링 방식은 크게 선점과 비선점으로 나뉘는데 선점은 프로세스에게 CPU를 할당시켰으나 우선순위가 높은 프로세스가 들어오면 할당된 걸 뺏는 구조다. 반면 **비선점은 프로세스가 일이 끝나거나 IO 블락이 오기 전까지는 계속 일을 시키는 것을 뜻함**

[스케쥴링 알고리즘 평가 요소]

프로세스 선점율 : CPU가 부지런하게 process 선점하고 있는가

처리율(Throughput) : 유닛타임당 얼마나 많은 일들 처리하는가

**반환시간** : 한 작업이 얼마나 빨리 끝나는가

**대기시간(Waiting Time)** : 프로세스가 CPU 할당받기 까지 얼마나 많이 `Ready Queue`에서 기다렸는가

반응 시간 : Interactive System에서 중요. 첫 응답이 나올때까지 걸리는 시간

크게 아래와 같은 알고리즘들이 있음.

### FCFS (First Come First Served)

FIFO와 비슷하게 먼저 들어온애를 먼저 처리하는 방식이다. 대표적인 비선점 방식임. 그러나 컨보이 효과로 늦게 들어온애가 굉장히 짧은 태스크(낮은 Burst Time)더라도 계속 기달려야 함

### SJF(Shortest Job First)

한 프로세스가 동작하는 동안 들어온 친구들 중 태스크 시간(Burst Time)이 짧은 친구들을 매겨서 실시간으로 해당 태스크를 먼저 부여하는 방식. 즉 짧은 애들 먼저 할당시키겠다는 이야기 (Python에서 min_heap을 통해 구현했었음)

- 선점, 비선점 모두 있음

### RR(Round Robin)

시간에 맞춰 프로세스를 분배함. 공정하게 배분함. RR은 선점 방식임.

### 우선순위 방식

우선순위 매겨진 프로세스들 중 높은 애들부터 실행시킴. 

[참고]

[https://zzsza.github.io/development/2018/07/29/cpu-scheduling-and-process/](https://zzsza.github.io/development/2018/07/29/cpu-scheduling-and-process/)

[https://jhnyang.tistory.com/34](https://jhnyang.tistory.com/34)

[https://wonit.tistory.com/104](https://wonit.tistory.com/104)

https://codedrive.tistory.com/129

# 알고리즘

### 이진탐색

정렬된 숫자들 사이에서 특정 값의 위치를 찾는 알고리즘. 보통 array.find 로 찾을 수 있으나 

배열에서 특정 값 이상, 혹은 그 사이에 값들이 몇개인지 찾을 때 이진탐색 알고리즘은 유용하게 사용된다.

python에서는 보통 bisect.bisect_left로 사용하면 해당 값의 인덱스, 그리고 그 값이 없다면 들어가야 할 인덱스 위치를 알려주므로 쉽게 계산할 수 있다.

bisect_right는 중복된 값이 있을 때 오른쪽 포지션을 알려줌. 만약 값이 없으면 -1ㅇ을 반환함

그리고 lower_bound와 upper_bound 개념이 있다. bisect_left는 lower_bound, bisect_right는 upper_bound라고 보면 된다.

# python

### List remove

리스트에서 특정 값을 지우기 위해선 remove를 사용하면 된다. 그러나 복수의 값들을 사용하기 위해선 filter를 사용해보는 것도 좋을 듯

```python
a = [1,2,3,3,4]
list(filter(lambda x: x!=3, a))
[for x in a if x != 3]
```

### [:-1]이란

마지막을 제외하고 전부 추출하는 것 -1은 마지막을 뜻하므로 처음부터 마지막 전까지 해서 마지막 제외한 나머지 추출하는 걸 뜻함