# Day14

### SOLID

객체지향을 구현하기 위해 지켜야하는 5가지 원칙.

Single Response Principle : 객체는 한가지의 책임만 가져야 한다. 높은 응집도와 낮은 결합도 고고

Open Closed Principle : 코드 변경에는 닫혀있고 확장에는 열려 있는 방향으로 코드를 작성해야 함. 캡슐화를 통해 Closed하고 확장할 수 있도록 인터페이스로 추상화해서 관리하기. 여기서 확장가능하다는 건 결국 추상화된 걸 상속받아서 오버라이드만 하면 빠르게 규격에 맞게 확장익 가능함.

Liskov Substitution Principle : 자식은 부모의 기능을 상속받아 사용할 수 있다

인터페이스 분리 법칙 : 인터페이스 단일 책임 원칙이라고 보면 됨. 인터페이스는 많이 쪼개면 좋다

의존성 역전 법칙 : 의존성 관계는 추상화된 것으로 받는게 더 의존성 줄이고 테스트 더 용이하게 해준다

- 보통 인터페이스나 추상 클래스로 객체 타입 선언
- 의존성 주입도 비슷한 예임

[https://myjamong.tistory.com/150](https://myjamong.tistory.com/150)

### 캡슐화

정보은닉을 해서 기존의 객체를 사용하는 다른 객체가 이를 변화시키지 못하게 하는 방법임

우선 캡슐화를 위해 접근 제어(public private protected)를 이용하고 메소드로 내부 변수를 통제한다

### 이벤트 드리븐

Event가 생겼을 때 이를 감지하고 소비하는 방향으로 프로그래밍하는 방식임. 기본적으로 Event 핸들러(consumer)가 이벤트 에미터에 의존성을 가지지 않아도 되서 MSA에서 자주 사용하는 방식임. 또한 자연스럽게 클라이언트는 이벤트를 보내고 서버의 응답과 무관하게 다른 일들을 할 수 있기에 비동기 처리가 가능해지고 추상화를 통한 확장이 용이해짐. 의존성이 사라진다는게 짱짱인듯 다만 이를 중재하는 채널에 강하게 의존하게 되어 이게 터지면 말짱 꽝임.

종류는 크게 2가지로 이벤트 리스너 방식과 이벤트 큐 방식이 있다.

1. EventEmitter가 이벤트를 채널로 보내면 이벤트 채널이 등록된 event listener의 method를 확인하고 호출하는 방식임. 보통 UI 프레임웤이 많이 사용함
2. Event를 Queue에 넣어두고 Event Loop가 이를 감지하여 Consumer에게 뿌려주는 방식이 있음. 비동기 메세징 큐들이 보통 이렇게 구현되어 있음

### BFS는 언제써야할까

기본적으로 완전탐색에 해당한다고 보면 됨. 노드들(그래프, 배열 등)이 있을 때 이를 깊이감으로 접근하냐 아니면 너비감으로 접근하냐 차이임. BFS, DFS 뭐로 구현해도 결국 결과가 나온다는 게 중요함.

배열에서 BFS를 쓸 때는 1. 특정 행동 양식이 정해져 있는 상태에서 2. 시간 같은 TImeStamp가 있어 접근의 Partition을 나눌 수 있어야 함

### ARRAY 팁

Array를 보통 순차적으로만 생각하는데 이렇게 생각해보는 건 어떨까?

- Array 순회를 한 시점에서 뒤를 되돌아본다 (Stack과 함께 이용할 수도 있겠찌?) →**다이내믹 프로그래밍이잖아 ㅋㅋㅋ**
- Array가 순회하면서 생기는 값을 담을 공간을 새로운 자료구조에 넣을지 아니면, 바깥 변수로 이전 상태값으로 처리를 할지 잘 생각해보기

### 카데인 알고리즘

최대 부분합을 구할 떄 사용되는 알고리즘이다.

[https://medium.com/@vdongbin/kadanes-algorithm-카데인-알고리즘-acbc8c279f29](https://medium.com/@vdongbin/kadanes-algorithm-%EC%B9%B4%EB%8D%B0%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-acbc8c279f29)