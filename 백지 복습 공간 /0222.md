# Day6-7

# Tree

### Tree의 정의 및 용어

정의 : Graph와 비슷하지만, 단방향이며 cyclic하지 않음

용어

- degree(자식 갯수)
- level(0부터 시작하는 깊이)
- root(최상단 노드)
- leaf(자식이 없는 노드)

### Binary Tree 유형

![https://i.imgur.com/QxvsFUN.png](https://i.imgur.com/QxvsFUN.png)

Full Binary Tree : 모든 노드가 0개 또는 2개의 자식을 가짐

Complete Binary Tree : 마지막 레벨을 제외하고 전부 노드가 채워져있는 이진 트리

Perfect Binary Tree :  모든 노드가 채워져있는 이진 트리

### Binary Tree 종류

BST(Binary Search Tree) 이진탐색 트리

부노 노드를 기준으로 우측 노드의 값은 부모보다 작고 좌측 노드는 부모보다 큰 구조

Balanced Tree

형제 노드끼리 서브트리의 높이가 1 이하로 차이나는 Tree

- Self Balancing binary search tree (삽입, 삭제 시 자동으로 정렬)
    - 레드블랙 트리
    - AVL
- B-Tree
- B+Tree (Binary는 아님)

Binary Heap

## Binary Heap

- 배열로 구현하는 편이며, Complete Binary Tree임. 최대 힙과 최소 힙 두가지 종류가 있음
- BST와 다르게 상/하 관계(자식노드들 보다 크거나 작거나)만 포함하며 좌/우 관계는 보장하지 않음(BST와 다름)
- 추출이
- 추출 : 루트 노드를 뽑아낸 후 맨 마지막 노드를 루트에 넣는다. 그리고 자식보다 값이 크면 스왑하면서 자리를 찾아나간다. O(logN)
- 삽입 : 맨 마지막 인덱스에 값을 추가한 후 위로 올라가면서 스왑시킨다. O(logN)

추출 : 시간복잡도 O(N)

## 순회 방식

크게 전위 순회, 중위 순회, 하위 순회로 나뉜다. 

전위 순회 : 부모  → 죄측 → 우측(NLR)

중위 순회 : 좌측 → 부모 → 우측(LNR)

후위 순회 : 좌측 → 우측 → 부모(LRN)

```python
def dfs(node):
	#print(node) 전위순회
	dfs(node.left)
	#print(node) 중위순회
	dfs(node.right)
	#print(node) 후위순회
```

- Stack으로도 구현이 가능함(DFS 대신)

    전위순회는 쉬운데 중위, 후위 순회로 가려면 이중 루프로 처리해야 함

# Python

### if else 한줄로 쓰기

```sql
a+b if a < b else a-b
```

### 파이썬 연산 줄바꿈하는 법

`\` 를 붙여서 긴 코드라인을 슬라이싱할 수 있음

```sql
a = 1 + 2 + 3 + \
	4 + 5 + 6 + \
	7 + 8
```

# CS

## 데이터베이스

### 파티셔닝과 샤딩

파티셔닝은 가용성과 성능을 위해 테이블을 쪼개는 방식으로 샤딩보다 더 포괄적인 방식. 샤딩은 데이터를 Row로 잘라서 따로 보관하는 방식이라고 보면 됨. 

여러가지 방식으로 파티셔닝이 가능함. Horizontal(샤딩), Vertical, Hash 등이 있음

### 리플리케이션 & 클러스터링 & 샤딩

데이터베이스를 여러개로 만드는 기술인데, 비용에 맞춰 잘 사용해야 함.

클러스터링 개념은 폭넓은 관점에서 보면 리플리케이션을 포함하는 의미인 듯(MongoDB가 그럼)

[https://mangkyu.tistory.com/97](https://mangkyu.tistory.com/97)

![https://i.imgur.com/ABROHmR.png](https://i.imgur.com/ABROHmR.png)

**클러스터링** : 데이터 베이스 서버를 여러 개를 두는 방식

- Active Active
- Active Standby

![https://i.imgur.com/VyMx0z2.png](https://i.imgur.com/VyMx0z2.png)

**리플리케이션** : DB 서버가 아닌 DB 스토리지를 복사하는 방식. 고가용성을 위해 DB 스토리지를 복사해서 수직적인 구조(Master Slave)로 관리하는 방식. 데이터가 비동기 방식으로 처리되어 일관성보장 안될 때가 있다

### Single Point of Failure

문제가 생겼을 때 전체 서비스가 중단되는 요소를 뜻함. SPOF를 줄여야 함.

## 네트워크

### 패킷

- 네트워크 통신시 한 번에 전송할 데이터 묶음
- Network Layer에서 패킷들이 잘개 쪼개짐(관리 용이, 에러 잡기 편함)
- DataLink Layer에서 패킷 → 프레임으로 캡슐화됨

### 네트워크 계층

OSI 7계층에서 3번째 역할을 맡음. IP 주소를 기반으로 해서 라우팅을 도움

실제 3계층까지 동작하는 기기로 L3 라우터(스위치)가 있으며 이는 IP를 통해 연결된 다른 디바이스에게 연결이 됨 (와이파이 공유기도 L3 라우터)

4계층의 메세지를 IP Diagram으로 바꿈(IP 캡슐화시키는 것임)

### Transport 계층

IP는 배송을 책임진다면 TCP는 실제 통신 흐름 관리와 오류 제어를 담당하는 친구.

통신 노드 간의 연결을 제어함

### L2,L3,L4 스위치

[https://pakss328.medium.com/로드밸런서란-l4-l7-501fd904cf05](https://pakss328.medium.com/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C%EB%9E%80-l4-l7-501fd904cf05)

L2 스위치는 2계층(DataLink)까지 동작하는 기기로 맥 주소를 기반으로 프레임을 전달해주는 역할. 보통 랜선 꼽아서 사용하는 기기들 생각해보면 됨.

L3 스위치(라우터)는 L2 기능을 포함하며 3계층(Network)까지 동작하는 기기. IP 주소 기반으로 라우팅을 도움

L4 스위치는 L3의 기능을 포함함. 4계층(Transport)까지 동작해서 TCP/UDP 정보와 IP를 바탕으로 더 강력한 밸런싱을 지원함

### TCP와 UDP

TCP와 UDP는 Transport Layer의 Protocol임. 참고로 Transport Layer는 메세지를 세그먼트로 쪼개는 역할을 함

먼저 TCP는 **신뢰성** 있는 **연결형** 서비스를 지원하는 프로토콜로 처음에 3way handshake와 끝에 4way handshake를 함. 또한 서버가 보낸 ACK라는 플래그를 수신자가 받아야만 정상적으로 송신이 되었다고 봄. 만약 제대로 ACK를 못받으면 재전송을 보내게 됨. 이때 재전송은 계속해서 보내지는 Timeout을 Linux Kernel 에서 설정할 수 있음. 

SYN 플래그는 처음 통신 전에 송신자가 문두들길 때 보내는 플래그임

UDP는 User Datagram Protocol로 비연결형 서비스를 지원하는 프로토콜임. 즉 연결 설정, 해제 과정이 존재하지 않음. TCP보다 속도가 빠름. Application Layer에서 커스터마이징이 가능